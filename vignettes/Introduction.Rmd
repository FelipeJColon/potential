---
title: "Introduction"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  message = FALSE, 
  warning = FALSE,
  collapse = TRUE,
  comment = "#>", 
  fig.width = 6,
  fig.height = 4
)
options(scipen = 1000)
```


Here we introduce the potential concepts and the package usage.

```{r setup, fig.cap="Population", echo=FALSE}
library(sf)
library(potential)
library(cartography)
x <- n3_pt[substr(n3_pt$ID,1,3) %in% c( "FRJ"), ]
x_poly <- n3_poly[substr(n3_poly$ID,1,3) %in% c( "FRJ"),]
x$POP19 <- round(x$POP19 / 1000, 0) 
par(mar = c(0,0,0,0))
plot(st_geometry(x_poly), col= "grey80", border = "white", lwd = .4)
propSymbolsLayer(x = x, var ="POP19", legend.pos = NA, 
                 col = "#940000", border = "white")
labelLayer(x, txt = "POP19", halo = T, pos = 4)

y <- st_as_sf(data.frame(ID = "A", x = 3700000, y = 2290000), 
              coords = c("x", "y"), crs = st_crs(x))

plot(y, pch = 23, add = T, bg = "blue", cex = 2)
```


```{r setup2, fig.cap = "Distance between x and y", echo = FALSE}
xy <- getLinkLayer(x = rbind(x[,"ID"], y), df = expand.grid(x = x$ID, y = y$ID))
xy$dist <- round(as.numeric(st_length(xy)) / 1000, 0)
xy$distlab <- paste0(round(as.numeric(st_length(xy)) / 1000, 0), " km")


par(mar = c(0,0,0,0))
plot(st_geometry(x_poly), col= "grey80", border = "white", lwd = .4)
propSymbolsLayer(x = x, var ="POP19", legend.pos = NA, 
                 col = "#94000033", border = "white")
plot(st_geometry(xy), add = T, lty = 2)
plot(y, pch = 23, add = T, bg = "blue", cex = 2)

labelLayer(xy, txt = "distlab", halo = T, col = "blue")
```


  

```{r, echo = FALSE, fig.cap = "."}
prob_interaction(fun = "e", span = 75 , beta = 2, limit = 300)
```

  
The probability of interaction at the span value (100 km) is 0.5. As the distance increase the probability disminish. 

We use the the values of interaction intensity for each distance between y and x points. 


```{r setup3, fig.cap = "Dis and y", echo = FALSE}
span <- 75
beta <- 2
alpha <- log(2) / span^beta
fric <- function(alpha, matdist, beta) {
    exp(-alpha * matdist^beta)
}

xy$friction <- fric(alpha, xy$dist, beta)

par(mar = c(0,0,0,0))
plot(st_geometry(x_poly), col= "grey80", border = "white", lwd = .4)
propSymbolsLayer(x = x, var ="POP19", legend.pos = NA, 
                 col = "#94000033", border = "white")
plot(st_geometry(xy), add = T, lty = 2)
plot(y, pch = 23, add = T, bg = "blue", cex = 2)

xy$frictionlab <- round(xy$friction,2)
labelLayer(xy, txt = "frictionlab", halo = T, col = "blue")
```
  

The contribution of each x point is equal to the probability of interaction multiplied by its mass.   

  

```{r, fig.cap="Contribution of each point", echo = FALSE}
xy <- merge(xy, st_drop_geometry(x), by.x = "x", by.y = "ID")
xy$m <- xy$POP19 * xy$friction
xy$mlab <- paste0(xy$frictionlab, " * ", xy$POP19, " = ", round(xy$m, 0))
par(mar = c(0,0,0,0))
plot(st_geometry(x_poly), col= "grey80", border = "white", lwd = .4)
propSymbolsLayer(x = x, var ="POP19", legend.pos = NA, 
                 col = "#94000033", border = "white")
plot(st_geometry(xy), add = T, lty = 2)
plot(y, pch = 23, add = T, bg = "blue", cex = 2)

xy$frictionlab <- round(xy$friction,2)
labelLayer(xy, txt = "mlab", halo = T, col = "blue")
```
  

```{r, fig.cap ="Contribution of each point", echo = FALSE}
x <- merge(x, st_drop_geometry(xy), by.x = "ID", by.y = "x")

x$mroun <- round(x$m, 0)
par(mar = c(0,0,0,0))
plot(st_geometry(x_poly), col= "grey80", border = "white", lwd = .4)
propSymbolsLayer(x = x, var ="POP19.x", legend.pos = NA, 
                 col = "#94000033", border = "white")
propSymbolsLayer(x = x, var ="mroun", legend.pos = NA, fixmax = max(x$POP19.x),
                 col = "#940000", border = "white")
plot(st_geometry(xy), add = T, lty = 2)

labelLayer(x, txt = "mroun", halo = T, col = "blue", pos = 4)

plot(y, pch = 23, add = T, bg = "blue", cex = 2)
```

The value of the potential at y position is the sum of each point contribution:   
4 + 9 + 478 + 57 + 13 + 59 + 322 + 305 + 157 + 85 + 479 + 4 + 34 = 2006.

This is how the potential values are computed. A common practice is to compute potential on points of a regular grid to esimate potentials on a pseudo-continue surface. 

We can use the same dataset as an example of use. 


`create_grid()` is used to create a regular grid with the extent of an existing layer (`x`) and a specific resolution (`res`). The resolution is set in units of the spatial layer (here in meters).


```{r, fig.cap="Regular grid"}
library(sf)
library(potential)
library(cartography)
x <- n3_pt[substr(n3_pt$ID,1,3) %in% c( "FRJ"), ]
x_poly <- n3_poly[substr(n3_poly$ID,1,3) %in% c( "FRJ"),]
x$POP19 <- round(x$POP19 / 1000, 0) 
par(mar = c(0,0,0,0))
plot(st_geometry(x_poly), col= "grey80", border = "white", lwd = .4)
propSymbolsLayer(x = x, var ="POP19", legend.pos = NA, 
                 col = "#940000", border = "white")

y <- create_grid(x = x_poly, res = 10000)

plot(st_geometry(y), pch = 23, add = TRUE, bg = "blue", cex = .5 )

```

`create_matrix()` is used to compute distances between objects. 

```{r}
d <- create_matrix(x = x, y = y)
d[1:5, 1:5]
```

The distance is expressed in map units (meters).

The `potential` function computes potentials. 

```{r, eval = F}
y_pot <- potential(x = x, y = y, d = d, var = "POP19", fun = "e", span = 100000, beta = 2)
par(mar = c(0,0,0,0))
plot(st_geometry(x_poly), col= "grey80", border = "white", lwd = .4)
propSymbolsLayer(y_pot, var = "OUTPUT", inches= .06, legend.style = "e", 
                 lwd = .5,
                 legend.frame = TRUE, legend.pos = "topleft")
```

It's possible to express the potential relatively to its maximum

```{r, eval = F}
y_pot$OUTPUT <- 100 * y_pot$OUTPUT / max(y_pot$OUTPUT)
par(mar = c(0,0,0,0))
plot(st_geometry(x_poly), col= "grey80", border = "white", lwd = .4)
propSymbolsLayer(y_pot, var = "OUTPUT", inches= .06, legend.style = "e", 
                 lwd = .5,
                 legend.frame = TRUE, legend.pos = "topleft")
```

It's also possible to use equipotential areas with `equipotential()`

```{r, eval = F}
par(mar = c(0,0,0,0))
iso <- equipotential(y_pot, breaks = seq(0,100, 10), mask = x_poly)
choroLayer(iso, var = "center", breaks = seq(0,100, 10), 
           col = hcl.colors(10, "cividis"), legend.pos = "topleft")
```

```{r, eval = F}

x[[c("POP18", "POP19")]]
```

